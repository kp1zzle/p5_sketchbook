(()=>{var n,e={9070:n=>{n.exports="precision highp float;\n/*\ncontributors: [Stefan Gustavson, Ian McEwan]\ndescription: modulus of 289\nuse: mod289(<float|vec2|vec3|vec4> x)\n*/\n\n#ifndef FNC_MOD289\n#define FNC_MOD289\n\nfloat mod289(const in float x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec2 mod289(const in vec2 x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec3 mod289(const in vec3 x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec4 mod289(const in vec4 x) { return x - floor(x * (1. / 289.)) * 289.; }\n\n#endif\n\n/*\ncontributors: [Stefan Gustavson, Ian McEwan]\ndescription: modulus of 289\nuse: mod289(<float|vec2|vec3|vec4> x)\n*/\n\n#ifndef FNC_MOD289\n#define FNC_MOD289\n\nfloat mod289(const in float x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec2 mod289(const in vec2 x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec3 mod289(const in vec3 x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec4 mod289(const in vec4 x) { return x - floor(x * (1. / 289.)) * 289.; }\n\n#endif\n\n\n/*\ncontributors: [Stefan Gustavson, Ian McEwan]\ndescription: permute\nuse: permute(<float|vec2|vec3|vec4> x)\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/math_functions.frag\n*/\n\n#ifndef FNC_PERMUTE\n#define FNC_PERMUTE\n\nfloat permute(const in float v) { return mod289(((v * 34.0) + 1.0) * v); }\nvec2 permute(const in vec2 v) { return mod289(((v * 34.0) + 1.0) * v); }\nvec3 permute(const in vec3 v) { return mod289(((v * 34.0) + 1.0) * v); }\nvec4 permute(const in vec4 v) { return mod289(((v * 34.0) + 1.0) * v); }\n\n#endif\n\n/*\ncontributors: [Stefan Gustavson, Ian McEwan]\ndescription: Fast, accurate inverse square root. \nuse: <float|vec2|vec3|vec4> taylorInvSqrt(<float|vec2|vec3|vec4> x)\n*/\n\n#ifndef FNC_TAYLORINVSQRT\n#define FNC_TAYLORINVSQRT\nfloat taylorInvSqrt(in float r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec2 taylorInvSqrt(in vec2 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec3 taylorInvSqrt(in vec3 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec4 taylorInvSqrt(in vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n#endif\n/*\ncontributors: [Stefan Gustavson, Ian McEwan]\ndescription: grad4, used for snoise(vec4 v)\nuse: grad4(<float> j, <vec4> ip)\n*/\n\n#ifndef FNC_GRAD4\n#define FNC_GRAD4\nvec4 grad4(float j, vec4 ip) {\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n    return p;\n}\n#endif\n\n\n/*\ncontributors: [Stefan Gustavson, Ian McEwan]\ndescription: Simplex Noise https://github.com/stegu/webgl-noise\nuse: snoise(<vec2|vec3|vec4> pos)\nlicense: |\n    Copyright 2021-2023 by Stefan Gustavson and Ian McEwan.\n    Published under the terms of the MIT license:\n    https://opensource.org/license/mit/\nexamples:\n    - /shaders/generative_snoise.frag\n*/\n\n#ifndef FNC_SNOISE\n#define FNC_SNOISE\nfloat snoise(in vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n\nfloat snoise(in vec3 v) {\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n            + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat snoise(in vec4 v) {\n    const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                        -0.447213595499958); // -1 + 4 * G4\n\n    // First corner\n    vec4 i  = floor(v + dot(v, vec4(.309016994374947451)) ); // (sqrt(5) - 1)/4\n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    //  i0.x = dot( isX, vec3( 1.0 ) );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    // i0 now contains the unique values 0,1,2,3 in each channel\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n    //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n    //  x1 = x0 - i1  + 1.0 * C.xxxx\n    //  x2 = x0 - i2  + 2.0 * C.xxxx\n    //  x3 = x0 - i3  + 3.0 * C.xxxx\n    //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n\n    // Permutations\n    i = mod289(i);\n    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute( permute( permute( permute (\n                i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n            + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n            + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n            + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4,p4));\n\n    // Mix contributions from the five corners\n    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\n\nvec2 snoise2( vec2 x ){\n    float s  = snoise(vec2( x ));\n    float s1 = snoise(vec2( x.y - 19.1, x.x + 47.2 ));\n    return vec2( s , s1 );\n}\n\nvec3 snoise3( vec3 x ){\n    float s  = snoise(vec3( x ));\n    float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n    float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n    return vec3( s , s1 , s2 );\n}\n\nvec3 snoise3( vec4 x ){\n    float s  = snoise(vec4( x ));\n    float s1 = snoise(vec4( x.y - 19.1 , x.z + 33.4 , x.x + 47.2, x.w ));\n    float s2 = snoise(vec4( x.z + 74.2 , x.x - 124.5 , x.y + 99.4, x.w ));\n    return vec3( s , s1 , s2 );\n}\n\n#endif\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: pass a value and get some random normalize value between 0 and 1\nuse: float random[2|3](<float|vec2|vec3> value)\noptions:\n    - RANDOM_HIGHER_RANGE: for working with a range over 0 and 1\n    - RANDOM_SINLESS: Use sin-less random, which tolerates bigger values before producing pattern. From https://www.shadertoy.com/view/4djSRW\n    - RANDOM_SCALE: by default this scale if for number with a big range. For producing good random between 0 and 1 use bigger range\nexamples:\n    - /shaders/generative_random.frag\n*/\n\n#ifndef RANDOM_SCALE\n#ifdef RANDOM_HIGHER_RANGE\n#define RANDOM_SCALE vec4(.1031, .1030, .0973, .1099)\n#else\n#define RANDOM_SCALE vec4(443.897, 441.423, .0973, .1099)\n#endif\n#endif\n\n#ifndef FNC_RANDOM\n#define FNC_RANDOM\nfloat random(in float x) {\n#ifdef RANDOM_SINLESS\n    x = fract(x * RANDOM_SCALE.x);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n#else\n    return fract(sin(x) * 43758.5453);\n#endif\n}\n\nfloat random(in vec2 st) {\n#ifdef RANDOM_SINLESS\n    vec3 p3  = fract(vec3(st.xyx) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n#else\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n#endif\n}\n\nfloat random(in vec3 pos) {\n#ifdef RANDOM_SINLESS\n    pos  = fract(pos * RANDOM_SCALE.xyz);\n    pos += dot(pos, pos.zyx + 31.32);\n    return fract((pos.x + pos.y) * pos.z);\n#else\n    return fract(sin(dot(pos.xyz, vec3(70.9898, 78.233, 32.4355))) * 43758.5453123);\n#endif\n}\n\nfloat random(in vec4 pos) {\n#ifdef RANDOM_SINLESS\n    pos = fract(pos * RANDOM_SCALE);\n    pos += dot(pos, pos.wzxy + 33.33);\n    return fract((pos.x + pos.y) * (pos.z + pos.w));\n#else\n    float dot_product = dot(pos, vec4(12.9898,78.233,45.164,94.673));\n    return fract(sin(dot_product) * 43758.5453);\n#endif\n}\n\nvec2 random2(float p) {\n    vec3 p3 = fract(vec3(p) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 random2(vec2 p) {\n    vec3 p3 = fract(p.xyx * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 random2(vec3 p3) {\n    p3 = fract(p3 * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 random3(float p) {\n    vec3 p3 = fract(vec3(p) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx); \n}\n\nvec3 random3(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nvec3 random3(vec3 p) {\n    p = fract(p * RANDOM_SCALE.xyz);\n    p += dot(p, p.yxz + 19.19);\n    return fract((p.xxy + p.yzz) * p.zyx);\n}\n\nvec4 random4(float p) {\n    vec4 p4 = fract(p * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);   \n}\n\nvec4 random4(vec2 p) {\n    vec4 p4 = fract(p.xyxy * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 random4(vec3 p) {\n    vec4 p4 = fract(p.xyzx * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 random4(vec4 p4) {\n    p4 = fract(p4  * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n#endif\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Worley noise\nuse: <vec2> worley(<vec2|vec3> pos)\nexamples:\n    - /shaders/generative_worley.frag\n*/\n\n#ifndef FNC_WORLEY\n#define FNC_WORLEY\n\nfloat worley(vec2 p){\n    vec2 n = floor( p );\n    vec2 f = fract( p );\n\n    float dis = 1.0;\n    for( int j= -1; j <= 1; j++ )\n        for( int i=-1; i <= 1; i++ ) {\t\n                vec2  g = vec2(i,j);\n                vec2  o = random2( n + g );\n                vec2  delta = g + o - f;\n                float d = length(delta);\n                dis = min(dis,d);\n    }\n\n    return 1.0-dis;\n}\n\nfloat worley(vec3 p) {\n    vec3 n = floor( p );\n    vec3 f = fract( p );\n\n    float dis = 1.0;\n    for( int k = -1; k <= 1; k++ )\n        for( int j= -1; j <= 1; j++ )\n            for( int i=-1; i <= 1; i++ ) {\t\n                vec3  g = vec3(i,j,k);\n                vec3  o = random3( n + g );\n                vec3  delta = g+o-f;\n                float d = length(delta);\n                dis = min(dis,d);\n    }\n\n    return 1.0-dis;\n}\n\n#endif\n\n#define MAX_EFFECTS 10\n\nuniform vec2 u_resolution;\nuniform sampler2D u_pixelArray;\nuniform float u_time;\n\nuniform int u_numEffects;\nuniform int u_effectTypes[MAX_EFFECTS];\nuniform vec2 u_effectCenters[MAX_EFFECTS];\nuniform vec2 u_effectDimensions[MAX_EFFECTS];\nuniform vec4 u_effectColors[MAX_EFFECTS];\nuniform vec4 u_effectSettings[MAX_EFFECTS];\n\nvarying vec2 vTexCoord;\n\nvec4 lerpBlend(vec4 top, vec4 back) {\n    return vec4((top.rgb * top.a + back.rgb * (1. - top.a)), 1);\n}\n\nbool isWithinDims(vec2 largePixelCoords, vec2 center, vec2 dims) {\n    if ((largePixelCoords.x >= center.x - (dims.x/2.)) && (largePixelCoords.x <= center.x + (dims.x/2.)) && (largePixelCoords.y >= center.y - (dims.y/2.)) && (largePixelCoords.y <= center.y + (dims.y/2.))) {\n        return true;\n    }\n    return false;\n}\n\nvec4 fillMode(vec4 color) {\n    if (color != vec4(0)) {\n        return color;\n    } else {\n        return vec4(1. - vTexCoord.x + sin(u_time*2.), 1. - vTexCoord.x + sin(u_time*3.), 1. - vTexCoord.x + sin(u_time*4.), 1.);\n    }\n}\n\nvec4 mountain(vec2 largePixelCoords, vec2 center, vec2 dims, vec4 color, vec4 settings) {\n    if (!isWithinDims(largePixelCoords, center, dims)) {\n        return vec4(0,0,0,0);\n    }\n\n    float cutoff = ((snoise(vec2(largePixelCoords.x/50.*settings.z + u_time/2.*settings.x,  u_time*settings.y)))/2. * dims.y);\n    if (largePixelCoords.y < cutoff + center.y) {\n        return vec4(0,0,0,0);\n\n    } else {\n        //        gl_FragColor = vec4(1. - (largePixelCoords.x / u_resolution.x), 1.- (largePixelCoords.y / u_resolution.y), u_time/10.,1);\n//        return vec4(1. - vTexCoord.x + sin(u_time*2.), 1. - vTexCoord.x + sin(u_time*3.), 1. - vTexCoord.x + sin(u_time*4.), 1.);\n        return fillMode(color);\n\n    }\n}\n\nvec4 dancingRect(vec2 largePixelCoords, vec2 center, vec2 dims, vec4 color, vec4 settings) {\n    if (!isWithinDims(largePixelCoords, center, dims + 2.*settings.x)) {\n        return vec4(0,0,0,0);\n    }\n\n     vec4 displacement = vec4(\n        snoise(vec2((largePixelCoords.x - center.x)/50. * settings.y + u_time*settings.z,  u_time * settings.a)) * settings.x,\n        snoise(vec2((dims.x/2. + largePixelCoords.y - center.y)/50. * settings.y - u_time*settings.z,  u_time * settings.a)) * settings.x,\n        snoise(vec2((dims.x + largePixelCoords.x - center.x)/50. * settings.y - u_time*settings.z,  u_time * settings.a)) * settings.x,\n        snoise(vec2((dims.x * 1.5 + largePixelCoords.y - center.y)/50. * settings.y + u_time*settings.z,  u_time * settings.a)) * settings.x\n     );\n\n    if (largePixelCoords.y < center.y + dims.y/2. - displacement.x &&\n    largePixelCoords.x < center.x + dims.x/2. - displacement.y&&\n    largePixelCoords.y > center.y - dims.y/2. + displacement.z &&\n    largePixelCoords.x > center.x - dims.x/2. + displacement.a) {\n        return vec4(0.9*sin(u_time*2.) , 0, 0.9, 1);\n    } else {\n        return vec4(0,0,0,0);\n\n    }\n}\n\nvec4 rect(vec2 largePixelCoords, vec2 center, vec2 dims, vec4 color) {\n    if (!isWithinDims(largePixelCoords, center, dims)) {\n        return vec4(0,0,0,0);\n    }\n        return fillMode(color);\n}\n\nvec4 circle(vec2 largePixelCoords, vec2 center, vec2 dims, vec4 color) {\n    largePixelCoords += 0.5;\n    float dist = distance(largePixelCoords, center);\n    if (dist <= dims.x/2.) {\n        return fillMode(color);\n    } else {\n        return vec4(0,0,0,0);\n    }\n}\n\nvec4 grid(vec2 largePixelCoords, vec2 center, vec2 dims, vec4 color) {\n    float v = 10.;\n    largePixelCoords += v/2.;\n    if (mod(largePixelCoords.x, v) == 0. && mod(largePixelCoords.y, v) == 0.) {\n        return fillMode(color);\n    } else {\n        return vec4(0,0,0,0);\n    }\n}\n\nvec4 stars(vec2 largePixelCoords, vec2 center, vec2 dims, vec4 color) {\n    float v = worley(largePixelCoords);\n    if (v >= 0.9 + sin(u_time)*0.01) {\n        return fillMode(color);\n    } else {\n        return vec4(0,0,0,0);\n\n    }\n}\n\n\n\nvoid main() {\n    vec2 largePixelCoords = floor(vTexCoord * u_resolution);\n    vec4 color = vec4(0);\n    for (int i = 0; i < MAX_EFFECTS; i++) {\n        if (u_effectTypes[i] == 1) {\n            color = mountain(largePixelCoords, u_effectCenters[i], u_effectDimensions[i], u_effectColors[i], u_effectSettings[i]);\n        } else if (u_effectTypes[i] == 2) {\n            color = rect(largePixelCoords, u_effectCenters[i], u_effectDimensions[i], u_effectColors[i]);\n        } else if (u_effectTypes[i] == 3) {\n            color = circle(largePixelCoords, u_effectCenters[i], u_effectDimensions[i], u_effectColors[i]);\n        } else if (u_effectTypes[i] == 4) {\n            color = stars(largePixelCoords, u_effectCenters[i], u_effectDimensions[i], u_effectColors[i]);\n        } else if (u_effectTypes[i] == 5) {\n            color = dancingRect(largePixelCoords, u_effectCenters[i], u_effectDimensions[i], u_effectColors[i], u_effectSettings[i]);\n        }else {\n            color = vec4(0,0,0,0);\n        }\n        gl_FragColor = lerpBlend(color, gl_FragColor);\n\n    }\n}\n\n"},9859:n=>{n.exports="// Determines how much precision the GPU uses when calculating floats\nprecision highp float;\n\n// Get the position attribute of the geometry\nattribute vec3 aPosition;\n\n// Get the texture coordinate attribute from the geometry\nattribute vec2 aTexCoord;\n\n// The view matrix defines attributes about the camera, such as focal length and camera position\n// Multiplying uModelViewMatrix * vec4(aPosition, 1.0) would move the object into its world position in front of the camera\nuniform mat4 uModelViewMatrix;\n\n// uProjectionMatrix is used to convert the 3d world coordinates into screen coordinates\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTexCoord;\n\nvoid main(void) {\n    vec4 positionVec4 = vec4(aPosition, 1.0);\n    gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n    vTexCoord = aTexCoord;\n}"},4363:(n,e,t)=>{"use strict";var o,i=t(4035),r=function(n,e){this.x=n,this.y=e};!function(n){n[n.Empty=0]="Empty",n[n.Mountain=1]="Mountain",n[n.Rect=2]="Rect",n[n.Circle=3]="Circle",n[n.Stars=4]="Stars",n[n.DancingRect=5]="DancingRect"}(o||(o={})),function(){function n(n,e,t,i,s,c){this.type=o.DancingRect,this.x=n,this.y=e,this.height=t,this.width=i,this.startPoint=new r(n,e),this.endPoint=s,this.secsPerOscillation=c,this.direction=1,this.color=null,this.settings=[10*Math.random(),2*Math.random(),5*Math.random(),5*Math.random()]}n.prototype.smoothstep=function(n,e,t){return(t=Math.max(0,Math.min(1,(t-n)/(e-n))))*t*(3-2*t)},n.prototype.setEffectStateForTime=function(n){this.x=this.startPoint.x+(this.endPoint.x-this.startPoint.x)*(this.smoothstep(0,this.secsPerOscillation/2,n%this.secsPerOscillation)-this.smoothstep(this.secsPerOscillation/2,this.secsPerOscillation,n%this.secsPerOscillation)),this.y=this.startPoint.y+(this.endPoint.y-this.startPoint.y)*(this.smoothstep(0,this.secsPerOscillation/2,n%this.secsPerOscillation)-this.smoothstep(this.secsPerOscillation/2,this.secsPerOscillation,n%this.secsPerOscillation)),(this.x>=this.endPoint.x||this.y>=this.endPoint.y)&&(this.direction*=-1)}}();var s=function(){function n(n,e,t,i,r,s){this.type=o.Stars,this.x=n,this.y=e,this.height=t,this.width=i,this.color=void 0!==r?r:null,this.settings=[Math.random(),Math.random(),Math.random(),Math.random()]}return n.prototype.setEffectStateForTime=function(n){},n}(),c=function(){function n(n,e,t,i,r){this.type=o.Rect,this.x=n,this.y=e,this.height=t,this.width=i,this.color=void 0!==r?r:null,this.settings=[Math.random(),Math.random(),Math.random(),Math.random()]}return n.prototype.setEffectStateForTime=function(n){},n}();new i((function(n){var e=128,o=10,i=0,r=[new s(64,64,e,e,n.color("#ffffff")),new c(64,64,96,96,n.color("#13c4b4"))],x=null,a=!0,v=0;n.setup=function(){o=n.min(window.innerWidth/e,window.innerHeight/e),n.createCanvas(o*e,o*e,n.WEBGL),n.background(220),n.noSmooth(),x=n.createShader(t(9859),t(9070)),n.noSmooth()},n.draw=function(){n.noStroke(),n.background(255),x.setUniform("u_time",i),x.setUniform("u_resolution",[e,e]);for(var t=[],o=[],s=[],c=[],l=[],f=0,d=r;f<d.length;f++){var p=d[f];p.setEffectStateForTime(i),t.push(p.type),o.push(p.x,p.y),s.push(p.width,p.height),null!==p.color?c.push(n.red(p.color)/255,n.green(p.color)/255,n.blue(p.color)/255,n.alpha(p.color)/255):c.push(0,0,0,0),l.push(p.settings[0],p.settings[1],p.settings[2],p.settings[3])}x.setUniform("u_effectTypes",t),x.setUniform("u_effectCenters",o),x.setUniform("u_effectDimensions",s),x.setUniform("u_effectColors",c),x.setUniform("u_effectSettings",l),n.shader(x),n.rect(0-n.width/2,0-n.height/2,n.width,n.height),0!==n.frameRate()&&(i+=1/n.frameRate()*.4,a&&Date.now()-v>1e3&&(console.log(n.frameRate().toFixed(0)),v=Date.now()))},n.keyPressed=function(){" "===n.key&&(a=!a),n.keyCode===n.ENTER&&(n.isLooping()?n.noLoop():n.loop())}}))}},t={};function o(n){var i=t[n];if(void 0!==i)return i.exports;var r=t[n]={exports:{}};return e[n](r,r.exports,o),r.exports}o.m=e,n=[],o.O=(e,t,i,r)=>{if(!t){var s=1/0;for(v=0;v<n.length;v++){for(var[t,i,r]=n[v],c=!0,x=0;x<t.length;x++)(!1&r||s>=r)&&Object.keys(o.O).every((n=>o.O[n](t[x])))?t.splice(x--,1):(c=!1,r<s&&(s=r));if(c){n.splice(v--,1);var a=i();void 0!==a&&(e=a)}}return e}r=r||0;for(var v=n.length;v>0&&n[v-1][2]>r;v--)n[v]=n[v-1];n[v]=[t,i,r]},o.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(n){if("object"==typeof window)return window}}(),o.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e),(()=>{var n={2835:0};o.O.j=e=>0===n[e];var e=(e,t)=>{var i,r,[s,c,x]=t,a=0;if(s.some((e=>0!==n[e]))){for(i in c)o.o(c,i)&&(o.m[i]=c[i]);if(x)var v=x(o)}for(e&&e(t);a<s.length;a++)r=s[a],o.o(n,r)&&n[r]&&n[r][0](),n[r]=0;return o.O(v)},t=self.webpackChunkp5_webpack_boilerplate=self.webpackChunkp5_webpack_boilerplate||[];t.forEach(e.bind(null,0)),t.push=e.bind(null,t.push.bind(t))})();var i=o.O(void 0,[4035],(()=>o(4363)));i=o.O(i)})();